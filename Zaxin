local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")

local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

local LoadingConfig = {
Duration = 8,
FadeOutTime = 1.5,
BarColor = Color3.fromRGB(200, 0, 255),
BarGlow = Color3.fromRGB(255, 100, 255),
BackgroundColor = Color3.fromRGB(10, 0, 20), 
TextColor = Color3.fromRGB(255, 200, 255),
ParticleCount = 150,
ParticleSpeed = 2,
ParticleSize = 3
}

local LoadingElements = {("Removendo falhas "),("Configurando Funções"),("Inicializando Mapa"),("Verificando Exploits"),("Carregando Script"),("Otimizando performance"),("Atualizando Funções Novas"),("Finalizando Sistema"),("Carregamento com Sucesso"),
}

local Particles = {}
local AnimationConnections = {}

local function CreateStarParticle(parent, x, y)
local star = Instance.new("Frame")
star.Name = "StarParticle"
star.Parent = parent
star.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
star.BorderSizePixel = 0
star.Size = UDim2.new(0, math.random(2, LoadingConfig.ParticleSize), 0, math.random(2, LoadingConfig.ParticleSize))
star.Position = UDim2.new(0, x, 0, y)
star.ZIndex = 8
star.BackgroundTransparency = math.random(0, 50) / 100

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(1, 0)
corner.Parent = star

local gradient = Instance.new("UIGradient")
gradient.Parent = star
gradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(147, 51, 234)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))
})

local particle = {
    frame = star,
    speedX = (math.random(-100, 100) / 100) * LoadingConfig.ParticleSpeed,
    speedY = (math.random(-100, 100) / 100) * LoadingConfig.ParticleSpeed,
    rotationSpeed = math.random(-5, 5),
    pulseSpeed = math.random(1, 3),
    opacity = math.random(30, 100) / 100
}

return particle
end

local function CreateParticleSystem(parent)
local screenSize = workspace.CurrentCamera.ViewportSize

for i = 1, LoadingConfig.ParticleCount do
    local x = math.random(0, screenSize.X)
    local y = math.random(0, screenSize.Y)
    local particle = CreateStarParticle(parent, x, y)
    table.insert(Particles, particle)
end
end

local RectangleParticles = {}

local function CreateRectangleParticle(parent, x)
local rect = Instance.new("Frame")
rect.Name = "RectangleParticle"
rect.Parent = parent
rect.Size = UDim2.new(0, math.random(8, 25), 0, math.random(15, 50)) 
rect.Position = UDim2.new(0, x, 0, -50) 
rect.BackgroundColor3 = Color3.fromRGB(200, 0, 255) 
rect.BorderSizePixel = 0
rect.ZIndex = 8
rect.BackgroundTransparency = math.random(20, 60) / 100 
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, math.random(2, 8))
corner.Parent = rect

local gradient = Instance.new("UIGradient")
gradient.Parent = rect
gradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(200, 0, 255)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 100, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(147, 51, 234))
})
gradient.Rotation = math.random(0, 360)

local particle = {
    frame = rect,
    speedY = math.random(3, 8),
    rotationSpeed = math.random(-2, 2), 
}

return particle
end

local function CreateRectangleSystem(parent)
local screenSize = workspace.CurrentCamera.ViewportSize
local spacing = 40
local columns = math.ceil(screenSize.X / spacing) 

for i = 1, columns do
    local x = (i - 1) * spacing + math.random(-15, 15) 
    for j = 1, math.random(8, 15) do 
        local delayedSpawn = math.random(0, 300) / 100
        task.delay(delayedSpawn * 0.01, function()
    local particle = CreateRectangleParticle(parent, x)
    table.insert(RectangleParticles, particle)
end)
    end
end
end

local function UpdateRectangles()
local screenSize = workspace.CurrentCamera.ViewportSize

for i, particle in pairs(RectangleParticles) do
    if particle.frame and particle.frame.Parent then
        local newY = particle.frame.Position.Y.Offset + particle.speedY
        particle.frame.Rotation = particle.frame.Rotation + particle.rotationSpeed
        local pulseValue = math.sin(tick() * 2 + i) * 0.2 + 0.5
        particle.frame.BackgroundTransparency = math.min(0.9, particle.frame.BackgroundTransparency + pulseValue * 0.1)
        if newY > screenSize.Y + 100 then
            newY = -50
            local newX = math.random(0, screenSize.X)
            particle.frame.Position = UDim2.new(0, newX, 0, newY)
        else
            particle.frame.Position = UDim2.new(0, particle.frame.Position.X.Offset, 0, newY)
        end
    end
end
end

local function UpdateParticles(parentFrame)
local screenSize = workspace.CurrentCamera.ViewportSize
for _, particle in pairs(Particles) do
    if particle.frame and particle.frame.Parent then
        local currentPos = particle.frame.Position
        local newX = currentPos.X.Offset + particle.speedX
        local newY = currentPos.Y.Offset + particle.speedY
        
        if newX < -10 then
            newX = screenSize.X + 10
        elseif newX > screenSize.X + 10 then
            newX = -10
        end
        
        if newY < -10 then
            newY = screenSize.Y + 10
        elseif newY > screenSize.Y + 10 then
            newY = -10
        end
        
        particle.frame.Position = UDim2.new(0, newX, 0, newY)
        particle.frame.Rotation = particle.frame.Rotation + particle.rotationSpeed
        
        local pulseValue = math.sin(tick() * particle.pulseSpeed * 2) * 0.4 + 0.6
        particle.frame.BackgroundTransparency = 1 - (particle.opacity * pulseValue)
        local sizeMultiplier = 1 + (math.sin(tick() * particle.pulseSpeed * 0.5) * 0.2)
        particle.frame.Size = UDim2.new(0, LoadingConfig.ParticleSize * sizeMultiplier, 0, LoadingConfig.ParticleSize * sizeMultiplier)
    end
end
end

local function CreateAdvancedBackground(parent)
local bgFrame = Instance.new("Frame")
bgFrame.Name = "AdvancedBackground"
bgFrame.Parent = parent
bgFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
bgFrame.BorderSizePixel = 0
bgFrame.Size = UDim2.new(1, 0, 1, 0)
bgFrame.Position = UDim2.new(0, 0, 0, 0)
bgFrame.ZIndex = 1

local gradient1 = Instance.new("UIGradient")
gradient1.Parent = bgFrame
gradient1.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(5, 5, 20)),
    ColorSequenceKeypoint.new(0.3, Color3.fromRGB(0, 0, 0)),
    ColorSequenceKeypoint.new(0.7, Color3.fromRGB(10, 0, 15)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
})
gradient1.Rotation = 45

local animateGradient = TweenService:Create(
    gradient1,
    TweenInfo.new(4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
    {Rotation = 225}
)
animateGradient:Play()
table.insert(AnimationConnections, animateGradient)

local overlay = Instance.new("Frame")
overlay.Name = "Overlay"
overlay.Parent = bgFrame
overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
overlay.BorderSizePixel = 0
overlay.Size = UDim2.new(1, 0, 1, 0)
overlay.Position = UDim2.new(0, 0, 0, 0)
overlay.ZIndex = 2
overlay.BackgroundTransparency = 0.3

local overlayGradient = Instance.new("UIGradient")
overlayGradient.Parent = overlay
overlayGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(20, 0, 30)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 0, 0)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(30, 0, 20))
})
overlayGradient.Rotation = -45

local animateOverlay = TweenService:Create(
    overlayGradient,
    TweenInfo.new(6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
    {Rotation = 315}
)
animateOverlay:Play()
table.insert(AnimationConnections, animateOverlay)

return bgFrame
end

local function CreatePulsingCircles(parent)
for i = 1, 5 do
    local circle = Instance.new("Frame")
    circle.Name = "PulsingCircle" .. i
    circle.Parent = parent
    circle.BackgroundColor3 = Color3.fromRGB(147, 51, 234)
    circle.BorderSizePixel = 0
    circle.Size = UDim2.new(0, 100 + (i * 50), 0, 100 + (i * 50))
    circle.Position = UDim2.new(0.5, -(50 + (i * 25)), 0.5, -(50 + (i * 25)))
    circle.ZIndex = 3
    circle.BackgroundTransparency = 0.8 + (i * 0.03)
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = circle
    
    local pulseTween = TweenService:Create(
        circle,
        TweenInfo.new(2 + (i * 0.3), Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
        {
            Size = UDim2.new(0, 120 + (i * 60), 0, 120 + (i * 60)),
            Position = UDim2.new(0.5, -(60 + (i * 30)), 0.5, -(60 + (i * 30))),
            BackgroundTransparency = 0.95
        }
    )
    pulseTween:Play()
    table.insert(AnimationConnections, pulseTween)
end
end

local function CreateLoadingScreen()
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "PremiumLoadingScreen"
ScreenGui.Parent = PlayerGui
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.ScreenInsets = Enum.ScreenInsets.None
ScreenGui.IgnoreGuiInset = true

local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Parent = ScreenGui
MainFrame.BackgroundColor3 = LoadingConfig.BackgroundColor
MainFrame.BorderSizePixel = 0
MainFrame.Size = UDim2.new(1, 0, 1, 0)
MainFrame.Position = UDim2.new(0, 0, 0, 0)
MainFrame.ZIndex = 10

local advancedBg = CreateAdvancedBackground(MainFrame)
CreatePulsingCircles(MainFrame)
CreateParticleSystem(MainFrame)
CreateRectangleSystem(MainFrame)

local CenterContainer = Instance.new("Frame")
CenterContainer.Name = "CenterContainer"
CenterContainer.Parent = MainFrame
CenterContainer.BackgroundTransparency = 1
CenterContainer.Size = UDim2.new(0, 600, 0, 400)
CenterContainer.Position = UDim2.new(0.5, -300, 0.5, -100)
CenterContainer.ZIndex = 11

local Icon = Instance.new("ImageLabel")
Icon.Name = "Icon"
Icon.Parent = CenterContainer
Icon.BackgroundTransparency = 1
Icon.Size = UDim2.new(0, 80, 0, 80)
Icon.Position = UDim2.new(0.5, -40, 0, -40)
Icon.Image = "rbxassetid://140695527589201"
Icon.ZIndex = 13

local iconRotation = TweenService:Create(
    Icon,
    TweenInfo.new(4, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, -1),
    {Rotation = 360}
)
iconRotation:Play()
table.insert(AnimationConnections, iconRotation)

local iconPulse = TweenService:Create(
    Icon,
    TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
    {
        Size = UDim2.new(0, 90, 0, 90),
        Position = UDim2.new(0.5, -45, 0, -45)
    }
)
iconPulse:Play()
table.insert(AnimationConnections, iconPulse)

local uiStroke = Instance.new("UIStroke")
uiStroke.Parent = Icon
uiStroke.Color = Color3.fromRGB(200, 0, 255)
uiStroke.Thickness = 3
uiStroke.Transparency = 0.3

local strokeGlow = TweenService:Create(
    uiStroke,
    TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
    {Transparency = 0.1, Thickness = 5}
)
strokeGlow:Play()
table.insert(AnimationConnections, strokeGlow)

local TitleLabel = Instance.new("TextLabel")
TitleLabel.Name = "TitleLabel"
TitleLabel.Parent = CenterContainer
TitleLabel.BackgroundTransparency = 1
TitleLabel.Size = UDim2.new(1, 0, 0, 80)
TitleLabel.Position = UDim2.new(0, 0, 0, 50)
TitleLabel.Text = "Zaxin Hub"
TitleLabel.TextColor3 = LoadingConfig.TextColor
TitleLabel.TextScaled = true
TitleLabel.Font = Enum.Font.GothamBold
TitleLabel.ZIndex = 12

local titleStroke = Instance.new("UIStroke")
titleStroke.Parent = TitleLabel
titleStroke.Color = Color3.fromRGB(147, 51, 234)
titleStroke.Thickness = 2
titleStroke.Transparency = 0.5

local TitleGradient = Instance.new("UIGradient")
TitleGradient.Parent = TitleLabel
TitleGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(147, 51, 234)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 255, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(147, 51, 234))
})

local titleAnimation = TweenService:Create(
    TitleGradient,
    TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
    {Offset = Vector2.new(2, 0)}
)
titleAnimation:Play()
table.insert(AnimationConnections, titleAnimation)

local glowTween = TweenService:Create(
    titleStroke,
    TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
    {Transparency = 0.1}
)
glowTween:Play()
table.insert(AnimationConnections, glowTween)

local SubtitleLabel = Instance.new("TextLabel")
SubtitleLabel.Name = "SubtitleLabel"
SubtitleLabel.Parent = MainFrame
SubtitleLabel.BackgroundTransparency = 1
SubtitleLabel.Size = UDim2.new(0, 400, 0, 40)
SubtitleLabel.Position = UDim2.new(0.5, -600, 1, -50) 
SubtitleLabel.Text = "discord no script"
SubtitleLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
SubtitleLabel.TextScaled = false
SubtitleLabel.TextSize = 12
SubtitleLabel.Font = Enum.Font.Gotham
SubtitleLabel.ZIndex = 12
SubtitleLabel.TextXAlignment = Enum.TextXAlignment.Center
SubtitleLabel.TextYAlignment = Enum.TextYAlignment.Bottom

local ProgressContainer = Instance.new("Frame")
ProgressContainer.Name = "ProgressContainer"
ProgressContainer.Parent = CenterContainer
ProgressContainer.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
ProgressContainer.BorderSizePixel = 0
ProgressContainer.Size = UDim2.new(1, 0, 0, 25)
ProgressContainer.Position = UDim2.new(0, 0, 0, 160)
ProgressContainer.ZIndex = 12

local ProgressCorner = Instance.new("UICorner")
ProgressCorner.CornerRadius = UDim.new(0, 12)
ProgressCorner.Parent = ProgressContainer

local ProgressStroke = Instance.new("UIStroke")
ProgressStroke.Parent = ProgressContainer
ProgressStroke.Color = LoadingConfig.BarGlow
ProgressStroke.Thickness = 2
ProgressStroke.Transparency = 0.3

local strokePulse = TweenService:Create(
    ProgressStroke,
    TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
    {Transparency = 0.1}
)
strokePulse:Play()
table.insert(AnimationConnections, strokePulse)

local ProgressBar = Instance.new("Frame")
ProgressBar.Name = "ProgressBar"
ProgressBar.Parent = ProgressContainer
ProgressBar.BackgroundColor3 = LoadingConfig.BarColor
ProgressBar.BorderSizePixel = 0
ProgressBar.Size = UDim2.new(0, 0, 1, 0)
ProgressBar.Position = UDim2.new(0, 0, 0, 0)
ProgressBar.ZIndex = 13

local BarCorner = Instance.new("UICorner")
BarCorner.CornerRadius = UDim.new(0, 12)
BarCorner.Parent = ProgressBar

local BarGradient = Instance.new("UIGradient")
BarGradient.Parent = ProgressBar
BarGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, LoadingConfig.BarColor),
    ColorSequenceKeypoint.new(0.5, LoadingConfig.BarGlow),
    ColorSequenceKeypoint.new(1, LoadingConfig.BarColor)
})

local barGradientAnim = TweenService:Create(
    BarGradient,
    TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
    {Offset = Vector2.new(1, 0)}
)
barGradientAnim:Play()
table.insert(AnimationConnections, barGradientAnim)

local PercentageLabel = Instance.new("TextLabel")
PercentageLabel.Name = "PercentageLabel"
PercentageLabel.Parent = CenterContainer
PercentageLabel.BackgroundTransparency = 1
PercentageLabel.Size = UDim2.new(1, 0, 0, 40)
PercentageLabel.Position = UDim2.new(0, 0, 0, 200)
PercentageLabel.Text = "0%"
PercentageLabel.TextColor3 = LoadingConfig.BarColor
PercentageLabel.TextScaled = true
PercentageLabel.Font = Enum.Font.GothamBold
PercentageLabel.ZIndex = 12

local StatusLabel = Instance.new("TextLabel")
StatusLabel.Name = "StatusLabel"
StatusLabel.Parent = CenterContainer
StatusLabel.BackgroundTransparency = 1
StatusLabel.Size = UDim2.new(1, 0, 0, 30)
StatusLabel.Position = UDim2.new(0, 0, 0, 250)
StatusLabel.Text = "Preparando..."
StatusLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
StatusLabel.TextScaled = true
StatusLabel.Font = Enum.Font.Gotham
StatusLabel.ZIndex = 12

local DotsLabel = Instance.new("TextLabel")
DotsLabel.Name = "DotsLabel"
DotsLabel.Parent = CenterContainer
DotsLabel.BackgroundTransparency = 1
DotsLabel.Size = UDim2.new(0, 60, 0, 30)
DotsLabel.Position = UDim2.new(1, -60, 0, 250)
DotsLabel.Text = ""
DotsLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
DotsLabel.TextScaled = true
DotsLabel.Font = Enum.Font.Gotham
DotsLabel.ZIndex = 12

return ScreenGui, ProgressBar, PercentageLabel, StatusLabel, DotsLabel, nil, MainFrame
end

local function AnimateDots(dotsLabel)
local dots = ""
local dotCount = 0

spawn(function()
    while dotsLabel.Parent do
        dotCount = (dotCount + 1) % 4
        dots = string.rep(".", dotCount)
        dotsLabel.Text = dots
        wait(0.4)
    end
end)
end

local function solutionsLoad()
local screenGui, progressBar, percentageLabel, statusLabel, dotsLabel, glowEffect, mainFrame = CreateLoadingScreen()

AnimateDots(dotsLabel)

local particleConnection = RunService.Heartbeat:Connect(function()
UpdateParticles(mainFrame)    
UpdateRectangles()            
end)
table.insert(AnimationConnections, particleConnection)

local startTime = tick()
local currentElementIndex = 1
local lastElementTime = startTime

local function updateProgress()
    local elapsed = tick() - startTime
    local progress = math.min(elapsed / LoadingConfig.Duration, 1)
    local percentage = math.floor(progress * 100)
    
    local barTween = TweenService:Create(
        progressBar,
        TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        {Size = UDim2.new(progress, 0, 1, 0)}
    )
    barTween:Play()
    
    local percentTween = TweenService:Create(
        percentageLabel,
        TweenInfo.new(0.1, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        {TextColor3 = Color3.fromRGB(147 + (percentage * 0.5), 51 + (percentage * 0.8), 234)}
    )
    percentTween:Play()
    
    percentageLabel.Text = percentage .. "%"
    
    local elementTime = LoadingConfig.Duration / #LoadingElements
    if tick() - lastElementTime >= elementTime and currentElementIndex <= #LoadingElements then
        statusLabel.Text = LoadingElements[currentElementIndex]
        
        local statusTween = TweenService:Create(
            statusLabel,
            TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
            {TextTransparency = 0}
        )
        statusTween:Play()
        
        currentElementIndex = currentElementIndex + 1
        lastElementTime = tick()
    end
    
    if progress >= 1 then
        wait(0.8)
        
        for _, connection in pairs(AnimationConnections) do
            if typeof(connection) == "RBXScriptConnection" then
                connection:Disconnect()
            elseif typeof(connection) == "Tween" then
                connection:Cancel()
            end
        end
        
        for _, particle in pairs(Particles) do
            if particle.frame then
                particle.frame:Destroy()
            end
        end
        
        local fadeOutTween = TweenService:Create(
            mainFrame,
            TweenInfo.new(LoadingConfig.FadeOutTime, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
            {
                BackgroundTransparency = 1,
                Size = UDim2.new(1.5, 0, 1.5, 0),
                Position = UDim2.new(-0.25, 0, -0.25, 0)
            }
        )
        
        local contentFadeTween = TweenService:Create(
            mainFrame.CenterContainer,
            TweenInfo.new(LoadingConfig.FadeOutTime * 0.7, Enum.EasingStyle.Back, Enum.EasingDirection.In),
            {
                Size = UDim2.new(0, 0, 0, 0),
                Position = UDim2.new(0.5, 0, 0.5, 0)
            }
        )
        
        fadeOutTween:Play()
        contentFadeTween:Play()
        
        fadeOutTween.Completed:Connect(function()
            screenGui:Destroy()
        end)
        
        return
    end
    
    RunService.Heartbeat:Wait()
    updateProgress()
end

updateProgress()
end

solutionsLoad()





-- Library do Hub Preto e roxa --
local success, redzlib = pcall(function()
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/267266273ffsfs/slapowsoufoda/refs/heads/main/Main.txt"))()
end)
if not success or not redzlib then
    warn("Falha ao carregar a library. Verifique o link e o executor.")
    return
end

local Window = redzlib:MakeWindow({
    Title = "Zaxin Hub | Brookhaven RP 🏡🌌",
    SubTitle = "by Zayun",
    SaveFolder = "Zaxin Hub.2025"
})

Window:AddMinimizeButton({
    Button = { Image = "rbxassetid://140695527589201", BackgroundTransparency = 0 },
    Corner = { CornerRadius = UDim.new(35, 1) },
})

-- abas
local Tab1 = Window:MakeTab({"Credits", "info"})
local Tab2 = Window:MakeTab({"Fun", "fun"})
local Tab3 = Window:MakeTab({"Troll", "skull"})
local Tab4 = Window:MakeTab({"OP", "home"})
local Tab5 = Window:MakeTab({"Teleporte", "map-pin"})
local Tab6 = Window:MakeTab({"Proteção", "shieldcheck"})

-- Tab1
local Section = Tab1:AddSection({"Servidor Discord"})
Tab1:AddDiscordInvite({
    Name = "Zaxin Hub",
    Description = "Entre no nosso servidor e fique por Dentro das novidades!",
    Logo = "rbxassetid://140695527589201",
    Invite = "https://discord.gg/8qtSfVsfg",
})
local Section = Tab1:AddSection({"Informações Do Script"})
local Paragraph = Tab1:AddParagraph({"Criador do Hub: Zayun", "Versão do Hub: 0.2"})
local Paragraph = Tab1:AddParagraph({"Designer do Hub", "Retx e Thur"})
local Paragraph = Tab1:AddParagraph({"sz.zxb", "Assistente e Sub Progamador"})

-- Tab2
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

local selectedPlayerName = nil
local headsitActive = false

local function headsitOnPlayer(targetPlayer)
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")

    if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("Head") then
        warn("Jogador alvo sem cabeça ou personagem.")
        return false
    end
    local targetHead = targetPlayer.Character.Head
    local localRoot = character:FindFirstChild("HumanoidRootPart")
    if not localRoot then
        warn("Seu personagem não tem HumanoidRootPart.")
        return false
    end

    localRoot.CFrame = targetHead.CFrame * CFrame.new(0, 2.2, 0)

    for _, v in pairs(localRoot:GetChildren()) do
        if v:IsA("WeldConstraint") then
            v:Destroy()
        end
    end

    local weld = Instance.new("WeldConstraint")
    weld.Part0 = localRoot
    weld.Part1 = targetHead
    weld.Parent = localRoot

    if humanoid then
        humanoid.Sit = true
    end

    print("Headsit ativado em " .. targetPlayer.Name)
    return true
end

local function removeHeadsit()
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local localRoot = character:FindFirstChild("HumanoidRootPart")
    if localRoot then
        for _, v in pairs(localRoot:GetChildren()) do
            if v:IsA("WeldConstraint") then
                v:Destroy()
            end
        end
    end
    if humanoid then
        humanoid.Sit = false
    end

    print("Headsit desativado.")
end

-- Função para encontrar jogador por nome parcial
local function findPlayerByPartialName(partial)
    partial = partial:lower()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Name:lower():sub(1, #partial) == partial then
            return player
        end
    end
    return nil
end

-- Notificação com imagem do jogador
local function notifyPlayerSelected(player)
    local StarterGui = game:GetService("StarterGui")
    local thumbType = Enum.ThumbnailType.HeadShot
    local thumbSize = Enum.ThumbnailSize.Size100x100
    local content, _ = Players:GetUserThumbnailAsync(player.UserId, thumbType, thumbSize)

    StarterGui:SetCore("SendNotification", {
        Title = "Player Selecionado",
        Text = player.Name .. " foi selecionado!",
        Icon = content,
        Duration = 5
    })
end

-- TextBox para digitar nome do player
Tab2:AddTextBox({
    Name = "Nome do Jogador",
    Description = "Digite parte do nome",
    PlaceholderText = "ex: Zaxin",
    Callback = function(Value)
        local foundPlayer = findPlayerByPartialName(Value)
        if foundPlayer then
            selectedPlayerName = foundPlayer.Name
            notifyPlayerSelected(foundPlayer)
        else
            warn("Nenhum jogador encontrado com esse nome.")
        end
    end
})

-- Botão para ativar/desativar headsit
-- Botão para ativar/desativar headsit (versão simplificada)
Tab2:AddButton({"Headsit (Clique para desativar)", function()
    if not selectedPlayerName then
    
        return
    end

    if not headsitActive then
        local target = Players:FindFirstChild(selectedPlayerName)
        if target and headsitOnPlayer(target) then
            headsitActive = true
        end
    else
        removeHeadsit()
        headsitActive = false
    end
end})




Tab2:AddSlider({
    Name = "Speed Player",
    Increase = 1,
    MinValue = 16,
    MaxValue = 1000,
    Default = 16,
    Callback = function(Value)
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        
        if humanoid then
            humanoid.WalkSpeed = Value
        end
    end
 })
 
 Tab2:AddSlider({
    Name = "Jumppower",
    Increase = 1,
    MinValue = 50,
    MaxValue = 500,
    Default = 50,
    Callback = function(Value)
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        
        if humanoid then
            humanoid.JumpPower = Value
        end
    end
 })
 
 Tab2:AddSlider({
    Name = "Gravity",
    Increase = 1,
    MinValue = 0,
    MaxValue = 10000,
    Default = 196.2,
    Callback = function(Value)
        game.Workspace.Gravity = Value
    end
 })
 
 local InfiniteJumpEnabled = false
 
 game:GetService("UserInputService").JumpRequest:Connect(function()
    if InfiniteJumpEnabled then
       local character = game.Players.LocalPlayer.Character
       if character and character:FindFirstChild("Humanoid") then
          character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
       end
    end
 end)

 Tab2:AddButton({
    Name = "Reset",
    Callback = function()
        -- Resetar Speed
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = 16 -- Valor padrão do Speed
            humanoid.JumpPower = 50 -- Valor padrão do JumpPower
        end
        
        -- Resetar Gravity
        game.Workspace.Gravity = 196.2 -- Valor padrão da gravidade
        
        -- Desativar Infinite Jump
        InfiniteJumpEnabled = false
    end
})


-- Tab3 Troll
local Players = game:GetService("Players")

local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local selectedPlayer = nil
local isFollowingKill = false
local isFollowingPull = false
local running = false
local connection = nil
local flingConnection = nil
local originalPosition = nil
local savedPosition = nil
local originalProperties = {}
local selectedKillPullMethod = nil
local selectedFlingMethod = nil
local soccerBall = nil
local couch = nil
local isSpectating = false
local spectatedPlayer = nil
local characterConnection = nil
local flingToggle = nil

local SetNetworkOwnerEvent = Instance.new("RemoteEvent")
SetNetworkOwnerEvent.Name = "SetNetworkOwnerEvent_" .. tostring(math.random(1000, 9999))
SetNetworkOwnerEvent.Parent = ReplicatedStorage

local serverScriptCode = [[
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local event = ReplicatedStorage:WaitForChild("]] .. SetNetworkOwnerEvent.Name .. [[")
    
    event.OnServerEvent:Connect(function(player, part, networkOwner)
        if part and part:IsA("BasePart") then
            pcall(function()
                part:SetNetworkOwner(networkOwner)
                part.Anchored = false
                part.CanCollide = true
                part.CanTouch = true
            end)
        end
    end)
]]

pcall(function()
    loadstring(serverScriptCode)()
end)

local function disableCarClient()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local carClient = backpack:FindFirstChild("CarClient")
    if carClient and carClient:IsA("LocalScript") then
        carClient.Disabled = true
    end
end

local function enableCarClient()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local carClient = backpack:FindFirstChild("CarClient")
    if carClient and carClient:IsA("LocalScript") then
        carClient.Disabled = false
    end
end

local function getPlayerNames()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

local function updateDropdown(dropdown, spectateToggle)
    pcall(function()
        local currentValue = dropdown:Get()
        local playerNames = getPlayerNames()
        dropdown:Set(playerNames) -- Usando :Set como solicitado
        if currentValue and not table.find(playerNames, currentValue) then
            dropdown:Set("")
            selectedPlayer = nil
            if isSpectating then
                stopSpectating()
                if spectateToggle then
                    pcall(function() spectateToggle:Set(false) end)
                end
            end
            if running or isFollowingKill or isFollowingPull then
                running = false
                isFollowingKill = false
                isFollowingPull = false
                if connection then connection:Disconnect() connection = nil end
                if flingConnection then flingConnection:Disconnect() flingConnection = nil end
                if flingToggle then pcall(function() flingToggle:Set(false) end) end
            end
        elseif currentValue and table.find(playerNames, currentValue) then
            dropdown:Set(currentValue) -- Mantém seleção se jogador ainda está no jogo
        end
    end)
end





local function spectatePlayer(playerName)
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and targetPlayer ~= LocalPlayer then
        spectatedPlayer = targetPlayer
        isSpectating = true

        local function updateCamera()
            if not isSpectating or not spectatedPlayer then return end
            if spectatedPlayer.Character and spectatedPlayer.Character:FindFirstChild("Humanoid") then
                Workspace.CurrentCamera.CameraSubject = spectatedPlayer.Character.Humanoid
            else
                Workspace.CurrentCamera.CameraSubject = nil
            end
        end

        updateCamera()




        characterConnection = RunService.Heartbeat:Connect(function()
            if not isSpectating then
                characterConnection:Disconnect()
                characterConnection = nil
                return
            end
            pcall(updateCamera)
        end)

        spectatedPlayer.CharacterAdded:Connect(function()
            if isSpectating then updateCamera() end
        end)
    else
        isSpectating = false
        spectatedPlayer = nil
    end
end

local function stopSpectating()
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    isSpectating = false
    spectatedPlayer = nil

    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        Workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    else
        Workspace.CurrentCamera.CameraSubject = nil
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    end
end

-- Função para teletransportar para o jogador selecionado (com ancoragem segura)
local function teleportToPlayer(playerName)
    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if not myHRP or not myHumanoid then
            print("Seu personagem não está totalmente carregado para teletransporte.")
            return
        end

        -- Zerar a física do personagem antes do teleporte
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Velocity = Vector3.zero
                part.RotVelocity = Vector3.zero
                part.Anchored = true -- Ancorar temporariamente para evitar movimento
            end
        end

        -- Teleportar para a posição do jogador-alvo
        local success, errorMessage = pcall(function()
            myHRP.CFrame = CFrame.new(targetPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 2, 0)) -- Leve elevação para evitar colisão com o chão
        end)
        if not success then
            warn("Erro ao teletransportar: " .. tostring(errorMessage))
            return
        end

        -- Garantir que o Humanoid saia do estado sentado ou voando
        myHumanoid.Sit = false
        myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)

        -- Aguardar 0,5 segundos com o personagem ancorado
        task.wait(0.5)

        -- Desancorar todas as partes do personagem e restaurar física
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = false
                part.Velocity = Vector3.zero
                part.RotVelocity = Vector3.zero
            end
        end

        print("Teletransportado para o jogador: " .. playerName .. " com ancoragem segura.")
    else
        print("Jogador ou personagem não encontrado para teletransporte.")
    end
end

LocalPlayer.CharacterAdded:Connect(function(character)
    if isSpectating then
        stopSpectating()
        pcall(function() SpectateToggleTab10:Set(false) end)
    end
end)

local valor_do_nome_do_joagdor

local DropdownPlayerTab2 = Tab3:AddDropdown({
    Name = "Selecionar Jogador",
    Description = "Escolha um jogador",
    Default = "",
    Multi = false,
    Options = getPlayerNames(),
    Flag = "player list",
    Callback = function(selectedPlayerName)
        valor_do_nome_do_joagdor = selectedPlayerName
        if selectedPlayerName == "" or selectedPlayerName == nil then
            selectedPlayer = nil
            if running or isFollowingKill or isFollowingPull then
                running = false
                isFollowingKill = false
                isFollowingPull = false
                if connection then connection:Disconnect() end
                if flingConnection then flingConnection:Disconnect() end
                if flingToggle then pcall(function() flingToggle:Set(false) end) end
            end
            if isSpectating then stopSpectating() end
        else
            selectedPlayer = Players:FindFirstChild(selectedPlayerName)
            if isSpectating then
                stopSpectating()
                spectatePlayer(selectedPlayerName)
            end
        end
    end
})

function UptadePlayers()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Name ~= LocalPlayer.Name then
            table.insert(playerNames, player.Name)
        end
    end
    DropdownPlayerTab2:Set(playerNames)
end

Tab3:AddButton({"Atualizar lista", function()
    UptadePlayers()
end})

UptadePlayers()


Tab3:AddButton({
    Title = "Teleportar para Jogador",
    Desc = "Clique para teletransportar para o jogador selecionado",
    Callback = function()
        local selectedPlayerName = valor_do_nome_do_joagdor
        if selectedPlayerName and selectedPlayerName ~= "" then
            local success, errorMessage = pcall(teleportToPlayer, selectedPlayerName)
            if not success then
                warn("Erro ao teletransportar: " .. tostring(errorMessage))
            end
        else
            print("Selecione um jogador antes de teletransportar.")
        end
    end
})

local SpectateToggleTab10 = Tab3:AddToggle({
    Name = "Visualizar Jogador",
    Description = "Ativa/desativa a visualização do jogador selecionado",
    Default = false,
    Callback = function(state)
        if state then
            if selectedPlayer then
                pcall(spectatePlayer, selectedPlayer.Name)
            else
                SpectateToggleTab10:Set(false)
            end
        else
            pcall(stopSpectating)
        end
    end
})

-- Remoção automática de jogadores que saem
Players.PlayerRemoving:Connect(function(player)
    updateDropdown(DropdownPlayerTab2, SpectateToggleTab10)
    if selectedPlayer == player then
        selectedPlayer = nil
        if isSpectating then stopSpectating() end
        if running then
            running = false
            if connection then connection:Disconnect() connection = nil end
            if flingConnection then flingConnection:Disconnect() flingConnection = nil end
            if flingToggle then flingToggle:Set(false) end
        end
        SpectateToggleTab10:Set(false)
        DropdownPlayerTab2:Set("")
    end
end)

-- Atualização automática quando um novo jogador entra
Players.PlayerAdded:Connect(function()
    task.wait(1) -- pequeno delay para garantir que o jogador esteja pronto
    updateDropdown(DropdownPlayerTab2, SpectateToggleTab10)
end)

-- Inicializa o dropdown
updateDropdown(DropdownPlayerTab2, SpectateToggleTab10)


local Section = Tab3:AddSection({"Trolar Kill"})

local DropdownKillPullMethod = Tab3:AddDropdown({
    Name = "Kill or bring",
    Description = "Escolha o método para matar ou puxar",
    Options = {"Sofá", "Ônibus"},
    Callback = function(value)
        selectedKillPullMethod = value
    end
})

------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                   --fling com sofa--
------------------------------------------------------------------------------------------------------------------------------------------------------------------

local function equipSofa()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local sofa = backpack:FindFirstChild("Couch") or LocalPlayer.Character:FindFirstChild("Couch")
    if not sofa then
        local args = { [1] = "PickingTools", [2] = "Couch" }
        local success = pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))
        end)
        if not success then return false end
        repeat
            sofa = backpack:FindFirstChild("Couch")
            task.wait()
        until sofa or task.wait(5)
        if not sofa then return false end
    end
    if sofa.Parent ~= LocalPlayer.Character then
        sofa.Parent = LocalPlayer.Character
    end
    return true
end

local function killWithSofa(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then return end
    if not equipSofa() then return end
    isFollowingKill = true
    originalPosition = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
end

local function pullWithSofa(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then return end
    if not equipSofa() then return end
    isFollowingPull = true
    originalPosition = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
end

----------------------------------------------------------------------------
                                                   --fling com onibus--
----------------------------------------------------------------------------


local function killWithBus(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then return end
    local character = LocalPlayer.Character
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then return end
    savedPosition = myHRP.Position
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1181.83, 76.08, -1158.83))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        if humanoid then humanoid:ChangeState(Enum.HumanoidStateType.GettingUp) end
    end)
    task.wait(0.5)

    disableCarClient()

    local args = { [1] = "DeleteAllVehicles" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    args = { [1] = "PickingCar", [2] = "SchoolBus" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(1)
    local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
    if not vehiclesFolder then return end
    local busName = LocalPlayer.Name .. "Car"
    local bus = vehiclesFolder:FindFirstChild(busName)
    if not bus then return end
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1171.15, 79.45, -1166.2))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.Seated)
    end)
    local sitStart = tick()
    repeat
        task.wait()
        if tick() - sitStart > 10 then return end
    until humanoid.Sit
    for _, part in ipairs(bus:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
            pcall(function() part:SetNetworkOwner(nil) end)
        end
    end
    running = true
    connection = RunService.Stepped:Connect(function()
        if not running then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then part.CanCollide = false end
        end
    end)
    local lastUpdate = tick()
    local updateInterval = 0.05
    local startTime = tick()
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running then return end
        local targetCharacter = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
        local newTargetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")
        local newTargetHumanoid = targetCharacter:FindFirstChild("Humanoid")
        if not newTargetHRP or not newTargetHumanoid then return end
        if not myHRP or not humanoid then running = false return end
        if tick() - lastUpdate < updateInterval then return end
        lastUpdate = tick()
        local offset = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10))
        pcall(function()
            local targetPosition = newTargetHRP.Position + offset
            bus:PivotTo(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 12000),
                    math.rad(Workspace.DistributedGameTime * 15000),
                    math.rad(Workspace.DistributedGameTime * 18000)
                )
            )
        end)
        local playerSeated = false
        for _, seat in ipairs(bus:GetDescendants()) do
            if (seat:IsA("Seat") or seat:IsA("VehicleSeat")) and seat.Name ~= "VehicleSeat" then
                if seat.Occupant == newTargetHumanoid then
                    playerSeated = true
                    break
                end
            end
        end
        if playerSeated or tick() - startTime > 10 then
            running = false
            if connection then connection:Disconnect() connection = nil end
            if flingConnection then flingConnection:Disconnect() flingConnection = nil end
            pcall(function()
                bus:PivotTo(CFrame.new(Vector3.new(-76.6, -401.97, -84.26)))
            end)
            task.wait(0.5)

            disableCarClient()

            local args = { [1] = "DeleteAllVehicles" }
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
            end)
            if character then
                local myHRP = character:FindFirstChild("HumanoidRootPart")
                if myHRP and savedPosition then
                    pcall(function()
                        myHRP.Anchored = true
                        myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                        task.wait(0.2)
                        myHRP.Velocity = Vector3.zero
                        myHRP.RotVelocity = Vector3.zero
                        myHRP.Anchored = false
                        if humanoid then humanoid:ChangeState(Enum.HumanoidStateType.GettingUp) end
                    end)
                end
            end
            if character then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                        part.Velocity = Vector3.zero
                        part.RotVelocity = Vector3.zero
                    end
                end
            end
            local myHumanoid = character and character:FindFirstChild("Humanoid")
            if myHumanoid then myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true) end
            for _, seat in ipairs(Workspace:GetDescendants()) do
                if seat:IsA("Seat") or seat:IsA("VehicleSeat") then seat.Disabled = false end
            end
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeUp", 1)
            end)
        end
    end)
end

local followConnection
if followConnection then followConnection:Disconnect() end
followConnection = RunService.Heartbeat:Connect(function()
    if (isFollowingKill or isFollowingPull) and selectedPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
        pcall(function()
            local targetPosition = selectedPlayer.Character.HumanoidRootPart.Position
            LocalPlayer.Character:SetPrimaryPartCFrame(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 12000),
                    math.rad(Workspace.DistributedGameTime * 15000),
                    math.rad(Workspace.DistributedGameTime * 18000)
                )
            )
        end)
    end
end)

local sitCheckConnection
if sitCheckConnection then sitCheckConnection:Disconnect() end
sitCheckConnection = RunService.Heartbeat:Connect(function()
    if (isFollowingKill or isFollowingPull) and selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("Humanoid") then
        pcall(function()
            if selectedPlayer.Character.Humanoid.Sit then
                if isFollowingKill then
                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(0, -500, 0))
                        task.wait(0.5)
                        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer("PickingTools", "Couch")
                        task.wait(1)
                    end
                end
                isFollowingKill = false
                isFollowingPull = false
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and originalPosition then
                    local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                    if myHRP then
                        myHRP.Anchored = true
                        myHRP.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0))
                        task.wait(0.2)
                        myHRP.Velocity = Vector3.zero
                        myHRP.RotVelocity = Vector3.zero
                        myHRP.Anchored = false
                        if myHumanoid then myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp) end
                    end
                    originalPosition = nil
                end
            end
        end)
    end
end)

Tab3:AddButton({
    Name = "Kill",
    Description = "Inicia o kill com o método selecionado",
    Callback = function()
        if isFollowingKill or isFollowingPull or running then return end
        if not selectedPlayer or not selectedKillPullMethod then return end
        if selectedKillPullMethod == "Sofá" then
            killWithSofa(selectedPlayer)
        elseif selectedKillPullMethod == "Ônibus" then
            killWithBus(selectedPlayer)
        end
    end
})

Tab3:AddButton({
    Name = "Bring",
    Description = "Inicia o Bring com o método selecionado",
    Callback = function()
        if isFollowingKill or isFollowingPull or running then return end
        if not selectedPlayer or not selectedKillPullMethod or selectedKillPullMethod ~= "Sofá" then return end
        pullWithSofa(selectedPlayer)
    end
})




Tab3:AddButton({
    Name = "Parar Movimento",
    Description = "Para o movimento de matar ou puxar",
    Callback = function()
        isFollowingKill = false
        isFollowingPull = false
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
                part.Velocity = Vector3.zero
                part.RotVelocity = Vector3.zero
            end
        end
        local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if myHumanoid then myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true) end
        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") or seat:IsA("VehicleSeat") then seat.Disabled = false end
        end
        if originalPosition then
            local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if myHRP then
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if myHumanoid then myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp) end
            end
            originalPosition = nil
        end

        disableCarClient()

        local args = { [1] = "DeleteAllVehicles" }
        pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
        end)
    end
})

local Section = Tab3:AddSection({" Em breve"})





Tab4:AddButton({
    Name = "Ativar Skybox",
    Description = "Ativar o skybox personalizado",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local WearShirt = ReplicatedStorage.Remotes.WearShirt
        WearShirt:InvokeServer(98679358331654)

        local args = {{100839513065432}}
        game:GetService("ReplicatedStorage").Remotes.ChangeCharacterBody:InvokeServer(unpack(args))
        
        -- Animação
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:WaitForChild("Humanoid")
        
        local function LoadTrack(id)
            local newAnim = Instance.new("Animation")
            newAnim.AnimationId = "rbxassetid://" .. tostring(id)
            local newTrack = humanoid:LoadAnimation(newAnim)
            newTrack.Priority = Enum.AnimationPriority.Action4
            newTrack:Play(0.1, 1, 1)
            return newTrack
        end

        local EmoteId = 101852027997337
        LoadTrack(EmoteId)
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Skybox",
            Text = "Skybox ativado com sucesso!",
            Duration = 5
        })
    end
})

Tab4:AddButton({
    Name = "Desativar Skybox",
    Description = "Remover skybox personalizado",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Remote = ReplicatedStorage.Remotes.ResetCharacterAppearance
        pcall(function()
            Remote:FireServer()
        end)

        local player = game.Players.LocalPlayer
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
                    track:Stop()
                end
            end
        end
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Skybox",
            Text = "Skybox desativado!",
            Duration = 5
        })
    end
})







local Section = Tab5:AddSection({
    Name = "Teleports"
})

local teleportButtons = {
    {"Hotel", CFrame.new(192, 4, 272)},
    {"Urban Center", CFrame.new(136, 4, 117)},
    {"Criminal Area", CFrame.new(-119, -28, 235)},
    {"Abandoned House", CFrame.new(986, 4, 63)},
    {"Agency Portal", CFrame.new(672, 4, -296)},
    {"Hideout", CFrame.new(505, -75, 143)},
    {"School", CFrame.new(-312, 4, 211)},
    {"Burguer Barn", CFrame.new(161, 8, 52)},
    {"Starting Point", CFrame.new(-26, 4, -23)},
    {"Main Arch", CFrame.new(-589, 141, -59)},
    {"Hospital", CFrame.new(-309, 4, 71)},
    {"Agency Base", CFrame.new(179, 4, -464)},
    {"Hidden Place of the Workshop", CFrame.new(0, 4, -495)},
    {"Secret Place", CFrame.new(-343, 4, -613)},
    {"Isolated Island", CFrame.new(-1925, 23, 127)},
    {"Hotel Square", CFrame.new(182, 4, 150)},
    {"Climb Mountain", CFrame.new(-670, 251, 765)},
    {"Main Bank", CFrame.new(2.28, 4.65, 254.58)},
    {"Clothing Store", CFrame.new(-46.15, 4.65, 253.20)},
    {"Veterinary", CFrame.new(-88.48, 22.05, 262.34)},
    {"Dental Clinic", CFrame.new(-53.58, 22.15, 265.61)},
    {"Coffee", CFrame.new(-97.12, 4.65, 254.99)}
}

for _, btn in ipairs(teleportButtons) do
    Tab5:AddButton({
        Name = btn[1],
        Callback = function()
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.CFrame = btn[2]
            end
        end
    })
end




Tab6:AddButton({
    Name = "Proteção Bug",
    Description = "Cria uma Proteção contra bug all",
    Callback = function()
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer

        local blacklist = {
            {Name = "water", Class = "Part"},
        }

        local function neutralize(part)
            if part and part:IsA("BasePart") then
                pcall(function()
                    part.Anchored = true
                    part.CanCollide = false
                    part.Massless = true
                    part.Transparency = 1
                    part:ClearAllChildren()
                end)
                pcall(function()
                    part:Destroy()
                end)
            end
        end

        workspace.DescendantAdded:Connect(function(obj)
            for _, rule in ipairs(blacklist) do
                if obj.Name == rule.Name and obj.ClassName == rule.Class then
                    neutralize(obj)
                end
            end
        end)

        for _, obj in ipairs(workspace:GetDescendants()) do
            for _, rule in ipairs(blacklist) do
                if obj.Name == rule.Name and obj.ClassName == rule.Class then
                    neutralize(obj)
                end
            end
        end

        task.spawn(function()
            while task.wait(0.25) do
                for _, rule in ipairs(blacklist) do
                    for _, v in next, getnilinstances() do
                        if v.Name == rule.Name and v.ClassName == rule.Class then
                            neutralize(v)
                        end
                    end
                end
            end
        end)

        LocalPlayer.CharacterAdded:Connect(function(char)
            local hum = char:WaitForChild("Humanoid")
            hum.Touched:Connect(function(hit)
                for _, rule in ipairs(blacklist) do
                    if hit.Name == rule.Name and hit.ClassName == rule.Class then
                        neutralize(hit)
                    end
                end
            end)
        end)
    end
})
